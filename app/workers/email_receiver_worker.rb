class EmailReceiverWorker
  include Sidekiq::Worker
  include DedicatedSidekiqQueue

  def perform(raw)
    return unless Gitlab::IncomingEmail.enabled?

    begin
      Gitlab::Email::Receiver.new(raw).execute
    rescue => e
      handle_failure(raw, e)
    end
  end

  private

  def handle_failure(raw, e)
    Rails.logger.warn("电子邮件无法处理：#{e}\n\n#{raw}")

    return unless raw.present?

    can_retry = false
    reason =
      case e
      when Gitlab::Email::UnknownIncomingEmail
        "我们无法确定电子邮件是什么。请通过Web界面创建您的问题或评论。"
      when Gitlab::Email::SentNotificationNotFoundError
        "我们无法确定电子邮件的回复内容。请通过Web界面创建您的评论。"
      when Gitlab::Email::ProjectNotFound
        "我们找不到这个项目。请检查是否有拼写错误。"
      when Gitlab::Email::EmptyEmailError
        can_retry = true
        "看来电子邮件是空白的。确保您的回复是电子邮件的顶部，我们无法处理内联回复。"
      when Gitlab::Email::AutoGeneratedEmailError
        "电子邮件被标记为“自动生成”，我们不能接受。请通过Web界面创建您的评论。"
      when Gitlab::Email::UserNotFoundError
        "我们无法确定用户对应的电子邮件。请通过Web界面创建您的评论。"
      when Gitlab::Email::UserBlockedError
        "您的帐户已被锁定。如果您认为这是错误的，请联系工作人员。"
      when Gitlab::Email::UserNotAuthorizedError
        "您不能执行此操作。如果您认为这是错误的，请联系工作人员。"
      when Gitlab::Email::NoteableNotFoundError
        "你回复的事件不再存在，也许被删除了？如果您认为这是错误的，请联系工作人员。"
      when Gitlab::Email::InvalidNoteError,
           Gitlab::Email::InvalidIssueError
        can_retry = true
        e.message
      end

    if reason
      EmailRejectionMailer.rejection(reason, raw, can_retry).deliver_later
    end
  end
end
